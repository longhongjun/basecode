// @generated by "php idl.php inc {input.idl.php} {output.inc}"

#if EXT_TYPE == 0
"ftok", T(Int64), S(0), "pathname", T(String), NULL, S(0), NULL, S(0), "proj", T(String), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.ftok.php )\n *\n * The function converts the pathname of an existing accessible file and a\n * project identifier into an integer for use with for example shmop_open()\n * and other System V IPC keys.\n *\n * @pathname   string  Path to an accessible file.\n * @proj       string  Project identifier. This must be a one character\n *                     string.\n *\n * @return     int     On success the return value will be the created key\n *                     value, otherwise -1 is returned.\n */",
"msg_get_queue", T(Variant), S(0), "key", T(Int64), NULL, S(0), NULL, S(0), "perms", T(Int64), "i:438;", S(6), "0666", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-get-queue.php )\n *\n * msg_get_queue() returns an id that can be used to access the System V\n * message queue with the given key. The first call creates the message\n * queue with the optional perms. A second call to msg_get_queue() for the\n * same key will return a different message queue identifier, but both\n * identifiers access the same underlying message queue.\n *\n * @key        int     Message queue numeric ID\n * @perms      int     Queue permissions. Default to 0666. If the message\n *                     queue already exists, the perms will be ignored.\n *\n * @return     mixed   Returns a resource handle that can be used to access\n *                     the System V message queue.\n */",
"msg_queue_exists", T(Boolean), S(0), "key", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-queue-exists.php )\n *\n * msg_queue_exists() checks whether a message queue exists\n *\n * @key        int     Queue key.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"msg_send", T(Boolean), S(0), "queue", T(Object), NULL, S(0), NULL, S(0), "msgtype", T(Int64), NULL, S(0), NULL, S(0), "message", T(Variant), NULL, S(0), NULL, S(0), "serialize", T(Boolean), "b:1;", S(4), "true", S(0), "blocking", T(Boolean), "b:1;", S(4), "true", S(0), "errorcode", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-send.php )\n *\n * msg_send() sends a message of type msgtype (which MUST be greater than\n * 0) to the message queue specified by queue.\n *\n * @queue      resource\n *\n * @msgtype    int\n * @message    mixed\n * @serialize  bool    The optional serialize controls how the message is\n *                     sent. serialize defaults to TRUE which means that\n *                     the message is serialized using the same mechanism\n *                     as the session module before being sent to the\n *                     queue. This allows complex arrays and objects to be\n *                     sent to other PHP scripts, or if you are using the\n *                     WDDX serializer, to any WDDX compatible client.\n * @blocking   bool    If the message is too large to fit in the queue,\n *                     your script will wait until another process reads\n *                     messages from the queue and frees enough space for\n *                     your message to be sent. This is called blocking;\n *                     you can prevent blocking by setting the optional\n *                     blocking parameter to FALSE, in which case\n *                     msg_send() will immediately return FALSE if the\n *                     message is too big for the queue, and set the\n *                     optional errorcode to MSG_EAGAIN, indicating that\n *                     you should try to send your message again a little\n *                     later on.\n * @errorcode  mixed\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n *\n *                     Upon successful completion the message queue data\n *                     structure is updated as follows: msg_lspid is set to\n *                     the process-ID of the calling process, msg_qnum is\n *                     incremented by 1 and msg_stime is set to the current\n *                     time.\n */",
"msg_receive", T(Boolean), S(0), "queue", T(Object), NULL, S(0), NULL, S(0), "desiredmsgtype", T(Int64), NULL, S(0), NULL, S(0), "msgtype", T(Variant), NULL, S(0), NULL, S(1), "maxsize", T(Int64), NULL, S(0), NULL, S(0), "message", T(Variant), NULL, S(0), NULL, S(1), "unserialize", T(Boolean), "b:1;", S(4), "true", S(0), "flags", T(Int64), "i:0;", S(4), "0", S(0), "errorcode", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-receive.php )\n *\n * msg_receive() will receive the first message from the specified queue\n * of the type specified by desiredmsgtype.\n *\n * @queue      resource\n *\n * @desiredmsgtype\n *             int     If desiredmsgtype is 0, the message from the front\n *                     of the queue is returned. If desiredmsgtype is\n *                     greater than 0, then the first message of that type\n *                     is returned. If desiredmsgtype is less than 0, the\n *                     first message on the queue with the lowest type less\n *                     than or equal to the absolute value of\n *                     desiredmsgtype will be read. If no messages match\n *                     the criteria, your script will wait until a suitable\n *                     message arrives on the queue. You can prevent the\n *                     script from blocking by specifying MSG_IPC_NOWAIT in\n *                     the flags parameter.\n * @msgtype    mixed   The type of the message that was received will be\n *                     stored in this parameter.\n * @maxsize    int     The maximum size of message to be accepted is\n *                     specified by the maxsize; if the message in the\n *                     queue is larger than this size the function will\n *                     fail (unless you set flags as described below).\n * @message    mixed   The received message will be stored in message,\n *                     unless there were errors receiving the message.\n * @unserialize\n *             bool    If set to TRUE, the message is treated as though it\n *                     was serialized using the same mechanism as the\n *                     session module. The message will be unserialized and\n *                     then returned to your script. This allows you to\n *                     easily receive arrays or complex object structures\n *                     from other PHP scripts, or if you are using the WDDX\n *                     serializer, from any WDDX compatible source.\n *\n *                     If unserialize is FALSE, the message will be\n *                     returned as a binary-safe string.\n * @flags      int     The optional flags allows you to pass flags to the\n *                     low-level msgrcv system call. It defaults to 0, but\n *                     you may specify one or more of the following values\n *                     (by adding or ORing them together). Flag values for\n *                     msg_receive MSG_IPC_NOWAIT If there are no messages\n *                     of the desiredmsgtype, return immediately and do not\n *                     wait. The function will fail and return an integer\n *                     value corresponding to MSG_ENOMSG. MSG_EXCEPT Using\n *                     this flag in combination with a desiredmsgtype\n *                     greater than 0 will cause the function to receive\n *                     the first message that is not equal to\n *                     desiredmsgtype. MSG_NOERROR If the message is longer\n *                     than maxsize, setting this flag will truncate the\n *                     message to maxsize and will not signal an error.\n * @errorcode  mixed   If the function fails, the optional errorcode will\n *                     be set to the value of the system errno variable.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n *\n *                     Upon successful completion the message queue data\n *                     structure is updated as follows: msg_lrpid is set to\n *                     the process-ID of the calling process, msg_qnum is\n *                     decremented by 1 and msg_rtime is set to the current\n *                     time.\n */",
"msg_remove_queue", T(Boolean), S(0), "queue", T(Object), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-remove-queue.php )\n *\n * msg_remove_queue() destroys the message queue specified by the queue.\n * Only use this function when all processes have finished working with the\n * message queue and you need to release the system resources held by it.\n *\n * @queue      resource\n *                     Message queue resource handle\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"msg_set_queue", T(Boolean), S(0), "queue", T(Object), NULL, S(0), NULL, S(0), "data", T(Array), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-set-queue.php )\n *\n * msg_set_queue() allows you to change the values of the msg_perm.uid,\n * msg_perm.gid, msg_perm.mode and msg_qbytes fields of the underlying\n * message queue data structure.\n *\n * Changing the data structure will require that PHP be running as the\n * same user that created the queue, owns the queue (as determined by the\n * existing msg_perm.xxx fields), or be running with root privileges. root\n * privileges are required to raise the msg_qbytes values above the system\n * defined limit.\n *\n * @queue      resource\n *                     Message queue resource handle\n * @data       map     You specify the values you require by setting the\n *                     value of the keys that you require in the data\n *                     array.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"msg_stat_queue", T(Array), S(0), "queue", T(Object), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.msg-stat-queue.php )\n *\n * msg_stat_queue() returns the message queue meta data for the message\n * queue specified by the queue. This is useful, for example, to determine\n * which process sent the message that was just received.\n *\n * @queue      resource\n *                     Message queue resource handle\n *\n * @return     map     The return value is an array whose keys and values\n *                     have the following meanings: Array structure for\n *                     msg_stat_queue msg_perm.uid The uid of the owner of\n *                     the queue. msg_perm.gid The gid of the owner of the\n *                     queue. msg_perm.mode The file access mode of the\n *                     queue. msg_stime The time that the last message was\n *                     sent to the queue. msg_rtime The time that the last\n *                     message was received from the queue. msg_ctime The\n *                     time that the queue was last changed. msg_qnum The\n *                     number of messages waiting to be read from the\n *                     queue. msg_qbytes The maximum number of bytes\n *                     allowed in one message queue. On Linux, this value\n *                     may be read and modified via\n *                     /proc/sys/kernel/msgmnb. msg_lspid The pid of the\n *                     process that sent the last message to the queue.\n *                     msg_lrpid The pid of the process that received the\n *                     last message from the queue.\n */",
"sem_acquire", T(Boolean), S(0), "sem_identifier", T(Object), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.sem-acquire.php )\n *\n * sem_acquire() blocks (if necessary) until the semaphore can be\n * acquired. A process attempting to acquire a semaphore which it has\n * already acquired will block forever if acquiring the semaphore would\n * cause its maximum number of semaphore to be exceeded.\n *\n * After processing a request, any semaphores acquired by the process but\n * not explicitly released will be released automatically and a warning\n * will be generated.\n *\n * @sem_identifier\n *             resource\n *                     sem_identifier is a semaphore resource, obtained\n *                     from sem_get().\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"sem_get", T(Variant), S(0), "key", T(Int64), NULL, S(0), NULL, S(0), "max_acquire", T(Int64), "i:1;", S(4), "1", S(0), "perm", T(Int64), "i:438;", S(6), "0666", S(0), "auto_release", T(Boolean), "b:1;", S(4), "true", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.sem-get.php )\n *\n * sem_get() returns an id that can be used to access the System V\n * semaphore with the given key.\n *\n * A second call to sem_get() for the same key will return a different\n * semaphore identifier, but both identifiers access the same underlying\n * semaphore.\n *\n * @key        int\n * @max_acquire\n *             int     The number of processes that can acquire the\n *                     semaphore simultaneously is set to max_acquire.\n * @perm       int     The semaphore permissions. Actually this value is\n *                     set only if the process finds it is the only process\n *                     currently attached to the semaphore.\n * @auto_release\n *             bool    Specifies if the semaphore should be automatically\n *                     released on request shutdown.\n *\n * @return     mixed   Returns a positive semaphore identifier on success,\n *                     or FALSE on error.\n */",
"sem_release", T(Boolean), S(0), "sem_identifier", T(Object), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.sem-release.php )\n *\n * sem_release() releases the semaphore if it is currently acquired by the\n * calling process, otherwise a warning is generated.\n *\n * After releasing the semaphore, sem_acquire() may be called to\n * re-acquire it.\n *\n * @sem_identifier\n *             resource\n *                     A Semaphore resource handle as returned by\n *                     sem_get().\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"sem_remove", T(Boolean), S(0), "sem_identifier", T(Object), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.sem-remove.php )\n *\n * sem_remove() removes the given semaphore.\n *\n * After removing the semaphore, it is no more accessible.\n *\n * @sem_identifier\n *             resource\n *                     A semaphore resource identifier as returned by\n *                     sem_get().\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"shm_attach", T(Variant), S(0), "shm_key", T(Int64), NULL, S(0), NULL, S(0), "shm_size", T(Int64), "i:10000;", S(8), "10000", S(0), "shm_flag", T(Int64), "i:438;", S(6), "0666", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-attach.php )\n *\n * shm_attach() returns an id that can be used to access the System V\n * shared memory with the given key, the first call creates the shared\n * memory segment with memsize and the optional perm-bits perm.\n *\n * A second call to shm_attach() for the same key will return a different\n * shared memory identifier, but both identifiers access the same\n * underlying shared memory. memsize and perm will be ignored.\n *\n * @shm_key    int     A numeric shared memory segment ID\n * @shm_size   int     The memory size. If not provided, default to the\n *                     sysvshm.init_mem in the php.ini, otherwise 10000\n *                     bytes.\n * @shm_flag   int     The optional permission bits. Default to 0666.\n *\n * @return     mixed   Returns a shared memory segment identifier.\n */",
"shm_detach", T(Boolean), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-detach.php )\n *\n * shm_detach() disconnects from the shared memory given by the\n * shm_identifier created by shm_attach(). Remember, that shared memory\n * still exist in the Unix system and the data is still present.\n *\n * @shm_identifier\n *             int     A shared memory resource handle as returned by\n *                     shm_attach()\n *\n * @return     bool    shm_detach() always returns TRUE.\n */",
"shm_remove", T(Boolean), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-remove.php )\n *\n * shm_remove() removes the shared memory shm_identifier. All data will be\n * destroyed.\n *\n * @shm_identifier\n *             int     The shared memory identifier as returned by\n *                     shm_attach()\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"shm_get_var", T(Variant), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), "variable_key", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-get-var.php )\n *\n * shm_get_var() returns the variable with a given variable_key, in the\n * given shared memory segment. The variable is still present in the shared\n * memory.\n *\n * @shm_identifier\n *             int     Shared memory segment, obtained from shm_attach().\n * @variable_key\n *             int     The variable key.\n *\n * @return     mixed   Returns the variable with the given key.\n */",
"shm_has_var", T(Boolean), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), "variable_key", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-has-var.php )\n *\n * shm_has_var() checks whether a specific key exists inside a shared\n * memory segment.\n *\n * @shm_identifier\n *             int     Shared memory segment, obtained from shm_attach().\n * @variable_key\n *             int     The variable key.\n *\n * @return     bool    Returns TRUE if the entry exists, otherwise FALSE\n */",
"shm_put_var", T(Boolean), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), "variable_key", T(Int64), NULL, S(0), NULL, S(0), "variable", T(Some), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-put-var.php )\n *\n * shm_put_var() inserts or updates the variable with the given\n * variable_key.\n *\n * Warnings (E_WARNING level) will be issued if shm_identifier is not a\n * valid SysV shared memory index or if there was not enough shared memory\n * remaining to complete your request.\n *\n * @shm_identifier\n *             int     A shared memory resource handle as returned by\n *                     shm_attach()\n * @variable_key\n *             int     The variable key.\n * @variable   mixed   The variable. All variable-types are supported.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",
"shm_remove_var", T(Boolean), S(0), "shm_identifier", T(Int64), NULL, S(0), NULL, S(0), "variable_key", T(Int64), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.shm-remove-var.php )\n *\n * Removes a variable with a given variable_key and frees the occupied\n * memory.\n *\n * @shm_identifier\n *             int     The shared memory identifier as returned by\n *                     shm_attach()\n * @variable_key\n *             int     The variable key.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */",

#elif EXT_TYPE == 1

#elif EXT_TYPE == 2

#endif
