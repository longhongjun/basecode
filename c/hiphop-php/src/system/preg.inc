// @generated by "php idl.php inc {input.idl.php} {output.inc}"

#if EXT_TYPE == 0
"preg_grep", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "input", T(Array), NULL, S(0), NULL, S(0), "flags", T(Int32), "i:0;", S(4), "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-grep.php )\n *\n * Returns the array consisting of the elements of the input array that\n * match the given pattern.\n *\n * @pattern    string  The pattern to search for, as a string.\n * @input      map     The input array.\n * @flags      int     If set to PREG_GREP_INVERT, this function returns\n *                     the elements of the input array that do not match\n *                     the given pattern.\n *\n * @return     mixed   Returns an array indexed using the keys from the\n *                     input array.\n */",
"preg_match", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "subject", T(String), NULL, S(0), NULL, S(0), "matches", T(Variant), "N;", S(2), "null", S(1), "flags", T(Int32), "i:0;", S(4), "0", S(0), "offset", T(Int32), "i:0;", S(4), "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-match.php )\n *\n * Searches subject for a match to the regular expression given in\n * pattern.\n *\n * @pattern    string  The pattern to search for, as a string.\n * @subject    string  The input string.\n * @matches    mixed   If matches is provided, then it is filled with the\n *                     results of search. $matches[0] will contain the text\n *                     that matched the full pattern, $matches[1] will have\n *                     the text that matched the first captured\n *                     parenthesized subpattern, and so on.\n * @flags      int     flags can be the following flag: PREG_OFFSET_CAPTURE\n *                     If this flag is passed, for every occurring match\n *                     the appendant string offset will also be returned.\n *                     Note that this changes the value of matches into an\n *                     array where every element is an array consisting of\n *                     the matched string at offset 0 and its string offset\n *                     into subject at offset 1.\n * @offset     int     Normally, the search starts from the beginning of\n *                     the subject string. The optional parameter offset\n *                     can be used to specify the alternate place from\n *                     which to start the search (in bytes).\n *\n *                     Using offset is not equivalent to passing\n *                     substr($subject, $offset) to preg_match() in place\n *                     of the subject string, because pattern can contain\n *                     assertions such as ^, $ or (\?<=x). Compare:\n *\n *                     Array ( )\n *\n *                     while this example\n *\n *\n *\n *                     will produce Array ( [0] => Array ( [0] => def [1]\n *                     => 0 ) )\n *\n * @return     mixed   preg_match() returns the number of times pattern\n *                     matches. That will be either 0 times (no match) or 1\n *                     time because preg_match() will stop searching after\n *                     the first match. preg_match_all() on the contrary\n *                     will continue until it reaches the end of subject.\n *                     preg_match() returns FALSE if an error occurred.\n */",
"preg_match_all", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "subject", T(String), NULL, S(0), NULL, S(0), "matches", T(Variant), NULL, S(0), NULL, S(1), "flags", T(Int32), "i:0;", S(4), "0", S(0), "offset", T(Int32), "i:0;", S(4), "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-match-all.php )\n *\n * Searches subject for all matches to the regular expression given in\n * pattern and puts them in matches in the order specified by flags.\n *\n * After the first match is found, the subsequent searches are continued\n * on from end of the last match.\n *\n * @pattern    string  The pattern to search for, as a string.\n * @subject    string  The input string.\n * @matches    mixed   Array of all matches in multi-dimensional array\n *                     ordered according to flags.\n * @flags      int     Can be a combination of the following flags (note\n *                     that it doesn't make sense to use PREG_PATTERN_ORDER\n *                     together with PREG_SET_ORDER): PREG_PATTERN_ORDER\n *\n *                     Orders results so that $matches[0] is an array of\n *                     full pattern matches, $matches[1] is an array of\n *                     strings matched by the first parenthesized\n *                     subpattern, and so on.\n *\n *\n *\n *                     <b>example: </b>, <div align=left>this is a\n *                     test</div> example: , this is a test\n *\n *                     So, $out[0] contains array of strings that matched\n *                     full pattern, and $out[1] contains array of strings\n *                     enclosed by tags.\n * @offset     int     Orders results so that $matches[0] is an array of\n *                     first set of matches, $matches[1] is an array of\n *                     second set of matches, and so on.\n *\n *                     <b>example: </b>, example: <div align=\"left\">this\n *                     is a test</div>, this is a test\n *\n * @return     mixed   Returns the number of full pattern matches (which\n *                     might be zero), or FALSE if an error occurred.\n */",
"preg_replace", T(Variant), S(0), "pattern", T(Variant), NULL, S(0), NULL, S(0), "replacement", T(Variant), NULL, S(0), NULL, S(0), "subject", T(Variant), NULL, S(0), NULL, S(0), "limit", T(Int32), "i:-1;", S(5), "-1", S(0), "count", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-replace.php )\n *\n * Searches subject for matches to pattern and replaces them with\n * replacement.\n *\n * @pattern    mixed   The pattern to search for. It can be either a string\n *                     or an array with strings.\n *\n *                     The e modifier makes preg_replace() treat the\n *                     replacement parameter as PHP code after the\n *                     appropriate references substitution is done. Tip:\n *                     make sure that replacement constitutes a valid PHP\n *                     code string, otherwise PHP will complain about a\n *                     parse error at the line containing preg_replace().\n * @replacement\n *             mixed   The string or an array with strings to replace. If\n *                     this parameter is a string and the pattern parameter\n *                     is an array, all patterns will be replaced by that\n *                     string. If both pattern and replacement parameters\n *                     are arrays, each pattern will be replaced by the\n *                     replacement counterpart. If there are fewer elements\n *                     in the replacement array than in the pattern array,\n *                     any extra patterns will be replaced by an empty\n *                     string.\n *\n *                     replacement may contain references of the form \\\\n\n *                     or (since PHP 4.0.4) $n, with the latter form being\n *                     the preferred one. Every such reference will be\n *                     replaced by the text captured by the n'th\n *                     parenthesized pattern. n can be from 0 to 99, and\n *                     \\\\0 or $0 refers to the text matched by the whole\n *                     pattern. Opening parentheses are counted from left\n *                     to right (starting from 1) to obtain the number of\n *                     the capturing subpattern. To use backslash in\n *                     replacement, it must be doubled (\"\\\\\\\\\" PHP string).\n *\n *                     When working with a replacement pattern where a\n *                     backreference is immediately followed by another\n *                     number (i.e.: placing a literal number immediately\n *                     after a matched pattern), you cannot use the\n *                     familiar \\\\1 notation for your backreference. \\\\11,\n *                     for example, would confuse preg_replace() since it\n *                     does not know whether you want the \\\\1 backreference\n *                     followed by a literal 1, or the \\\\11 backreference\n *                     followed by nothing. In this case the solution is to\n *                     use \\${1}1. This creates an isolated $1\n *                     backreference, leaving the 1 as a literal.\n *\n *                     When using the e modifier, this function escapes\n *                     some characters (namely ', \", \\ and NULL) in the\n *                     strings that replace the backreferences. This is\n *                     done to ensure that no syntax errors arise from\n *                     backreference usage with either single or double\n *                     quotes (e.g. 'strlen(\\'$1\\')+strlen(\"$2\")'). Make\n *                     sure you are aware of PHP's string syntax to know\n *                     exactly how the interpreted string will look like.\n * @subject    mixed   The string or an array with strings to search and\n *                     replace.\n *\n *                     If subject is an array, then the search and replace\n *                     is performed on every entry of subject, and the\n *                     return value is an array as well.\n * @limit      int     The maximum possible replacements for each pattern\n *                     in each subject string. Defaults to -1 (no limit).\n * @count      mixed   If specified, this variable will be filled with the\n *                     number of replacements done.\n *\n * @return     mixed   preg_replace() returns an array if the subject\n *                     parameter is an array, or a string otherwise.\n *\n *                     If matches are found, the new subject will be\n *                     returned, otherwise subject will be returned\n *                     unchanged or NULL if an error occurred.\n */",
"preg_replace_callback", T(Variant), S(0), "pattern", T(Variant), NULL, S(0), NULL, S(0), "callback", T(Variant), NULL, S(0), NULL, S(0), "subject", T(Variant), NULL, S(0), NULL, S(0), "limit", T(Int32), "i:-1;", S(5), "-1", S(0), "count", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.preg-replace-callback.php )\n *\n * The behavior of this function is almost identical to preg_replace(),\n * except for the fact that instead of replacement parameter, one should\n * specify a callback.\n *\n * @pattern    mixed   The pattern to search for. It can be either a string\n *                     or an array with strings.\n * @callback   mixed   A callback that will be called and passed an array\n *                     of matched elements in the subject string. The\n *                     callback should return the replacement string.\n *\n *                     You'll often need the callback function for a\n *                     preg_replace_callback() in just one place. In this\n *                     case you can use an anonymous function (since PHP\n *                     5.3.0) or create_function() to declare an anonymous\n *                     function as callback within the call to\n *                     preg_replace_callback(). By doing it this way you\n *                     have all information for the call in one place and\n *                     do not clutter the function namespace with a\n *                     callback function's name not used anywhere else.\n *\n *                     Example #1 preg_replace_callback() and\n *                     create_function()\n * @subject    mixed   The string or an array with strings to search and\n *                     replace.\n * @limit      int     The maximum possible replacements for each pattern\n *                     in each subject string. Defaults to -1 (no limit).\n * @count      mixed   If specified, this variable will be filled with the\n *                     number of replacements done.\n *\n * @return     mixed   preg_replace_callback() returns an array if the\n *                     subject parameter is an array, or a string\n *                     otherwise. On errors the return value is NULL\n *\n *                     If matches are found, the new subject will be\n *                     returned, otherwise subject will be returned\n *                     unchanged.\n */",
"preg_split", T(Variant), S(0), "pattern", T(Variant), NULL, S(0), NULL, S(0), "subject", T(Variant), NULL, S(0), NULL, S(0), "limit", T(Int32), "i:-1;", S(5), "-1", S(0), "flags", T(Int32), "i:0;", S(4), "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-split.php )\n *\n * Split the given string by a regular expression.\n *\n * @pattern    mixed   The pattern to search for, as a string.\n * @subject    mixed   The input string.\n * @limit      int     If specified, then only substrings up to limit are\n *                     returned with the rest of the string being placed in\n *                     the last substring. A limit of -1, 0 or null means\n *                     \"no limit\" and, as is standard across PHP, you can\n *                     use null to skip to the flags parameter.\n * @flags      int     flags can be any combination of the following flags\n *                     (combined with the | bitwise operator):\n *                     PREG_SPLIT_NO_EMPTY If this flag is set, only\n *                     non-empty pieces will be returned by preg_split().\n *\n * @return     mixed   Returns an array containing substrings of subject\n *                     split along boundaries matched by pattern.\n */",
"preg_quote", T(String), S(0), "str", T(String), NULL, S(0), NULL, S(0), "delimiter", T(String), "N;", S(2), "null", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-quote.php )\n *\n * preg_quote() takes str and puts a backslash in front of every character\n * that is part of the regular expression syntax. This is useful if you\n * have a run-time string that you need to match in some text and the\n * string may contain special regex characters.\n *\n * The special regular expression characters are: . \\ + * \? [ ^ ] $ ( ) {\n * } = ! < > | : -\n *\n * @str        string  The input string.\n * @delimiter  string  If the optional delimiter is specified, it will also\n *                     be escaped. This is useful for escaping the\n *                     delimiter that is required by the PCRE functions.\n *                     The / is the most commonly used delimiter.\n *\n * @return     string  Returns the quoted string.\n */",
"preg_last_error", T(Int64), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.preg-last-error.php )\n *\n * Returns the error code of the last PCRE regex execution.\n *\n * Example #1 preg_last_error() example\n *\n *\n *\n * Backtrack limit was exhausted!\n *\n * @return     int     Returns one of the following constants (explained on\n *                     their own page): PREG_NO_ERROR PREG_INTERNAL_ERROR\n *                     PREG_BACKTRACK_LIMIT_ERROR (see also\n *                     pcre.backtrack_limit) PREG_RECURSION_LIMIT_ERROR\n *                     (see also pcre.recursion_limit) PREG_BAD_UTF8_ERROR\n *                     PREG_BAD_UTF8_OFFSET_ERROR (since PHP 5.3.0)\n */", 
"ereg_replace", T(String), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "replacement", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.ereg-replace.php )\n *\n *\n * @pattern    string  A POSIX extended regular expression.\n * @replacement\n *             string  If pattern contains parenthesized substrings,\n *                     replacement may contain substrings of the form\n *                     \\\\digit, which will be replaced by the text matching\n *                     the digit'th parenthesized substring; \\\\0 will\n *                     produce the entire contents of string. Up to nine\n *                     substrings may be used. Parentheses may be nested,\n *                     in which case they are counted by the opening\n *                     parenthesis.\n * @str        string  The input string.\n *\n * @return     string  The modified string is returned. If no matches are\n *                     found in string, then it will be returned unchanged.\n */",
"eregi_replace", T(String), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "replacement", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.eregi-replace.php )\n *\n * This function is identical to ereg_replace() except that this ignores\n * case distinction when matching alphabetic characters. WarningThis\n * function has been DEPRECATED as of PHP 5.3.0. Relying on this feature is\n * highly discouraged.\n *\n * @pattern    string  A POSIX extended regular expression.\n * @replacement\n *             string  If pattern contains parenthesized substrings,\n *                     replacement may contain substrings of the form\n *                     \\\\digit, which will be replaced by the text matching\n *                     the digit'th parenthesized substring; \\\\0 will\n *                     produce the entire contents of string. Up to nine\n *                     substrings may be used. Parentheses may be nested,\n *                     in which case they are counted by the opening\n *                     parenthesis.\n * @str        string  The input string.\n *\n * @return     string  The modified string is returned. If no matches are\n *                     found in string, then it will be returned unchanged.\n */",
"ereg", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), "regs", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.ereg.php )\n *\n *\n * @pattern    string  Case sensitive regular expression.\n * @str        string  The input string.\n * @regs       mixed   If matches are found for parenthesized substrings of\n *                     pattern and the function is called with the third\n *                     argument regs, the matches will be stored in the\n *                     elements of the array regs.\n *\n *                     $regs[1] will contain the substring which starts at\n *                     the first left parenthesis; $regs[2] will contain\n *                     the substring starting at the second, and so on.\n *                     $regs[0] will contain a copy of the complete string\n *                     matched.\n *\n * @return     mixed   Returns the length of the matched string if a match\n *                     for pattern was found in string, or FALSE if no\n *                     matches were found or an error occurred.\n *\n *                     If the optional parameter regs was not passed or\n *                     the length of the matched string is 0, this function\n *                     returns 1.\n */",
"eregi", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), "regs", T(Variant), "N;", S(2), "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.eregi.php )\n *\n * This function is identical to ereg() except that it ignores case\n * distinction when matching alphabetic characters. WarningThis function\n * has been DEPRECATED as of PHP 5.3.0. Relying on this feature is highly\n * discouraged.\n *\n * @pattern    string  Case insensitive regular expression.\n * @str        string  The input string.\n * @regs       mixed   If matches are found for parenthesized substrings of\n *                     pattern and the function is called with the third\n *                     argument regs, the matches will be stored in the\n *                     elements of the array regs.\n *\n *                     $regs[1] will contain the substring which starts at\n *                     the first left parenthesis; $regs[2] will contain\n *                     the substring starting at the second, and so on.\n *                     $regs[0] will contain a copy of the complete string\n *                     matched.\n *\n * @return     mixed   Returns the length of the matched string if a match\n *                     for pattern was found in string, or FALSE if no\n *                     matches were found or an error occurred.\n *\n *                     If the optional parameter regs was not passed or\n *                     the length of the matched string is 0, this function\n *                     returns 1.\n */",
"split", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), "limit", T(Int32), "i:-1;", S(5), "-1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.split.php )\n *\n * Splits a string into array by regular expression. WarningThis function\n * has been DEPRECATED as of PHP 5.3.0. Relying on this feature is highly\n * discouraged.\n *\n * @pattern    string  Case sensitive regular expression.\n *\n *                     If you want to split on any of the characters which\n *                     are considered special by regular expressions,\n *                     you'll need to escape them first. If you think\n *                     split() (or any other regex function, for that\n *                     matter) is doing something weird, please read the\n *                     file regex.7, included in the regex/ subdirectory of\n *                     the PHP distribution. It's in manpage format, so\n *                     you'll want to do something along the lines of man\n *                     /usr/local/src/regex/regex.7 in order to read it.\n * @str        string  The input string.\n * @limit      int     If limit is set, the returned array will contain a\n *                     maximum of limit elements with the last element\n *                     containing the whole rest of string.\n *\n * @return     mixed   Returns an array of strings, each of which is a\n *                     substring of string formed by splitting it on\n *                     boundaries formed by the case-sensitive regular\n *                     expression pattern.\n *\n *                     If there are n occurrences of pattern, the returned\n *                     array will contain n+1 items. For example, if there\n *                     is no occurrence of pattern, an array with only one\n *                     element will be returned. Of course, this is also\n *                     true if string is empty. If an error occurs, split()\n *                     returns FALSE.\n */",
"spliti", T(Variant), S(0), "pattern", T(String), NULL, S(0), NULL, S(0), "str", T(String), NULL, S(0), NULL, S(0), "limit", T(Int32), "i:-1;", S(5), "-1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.spliti.php )\n *\n * Splits a string into array by regular expression.\n *\n * This function is identical to split() except that this ignores case\n * distinction when matching alphabetic characters. WarningThis function\n * has been DEPRECATED as of PHP 5.3.0. Relying on this feature is highly\n * discouraged.\n *\n * @pattern    string  Case insensitive regular expression.\n *\n *                     If you want to split on any of the characters which\n *                     are considered special by regular expressions,\n *                     you'll need to escape them first. If you think\n *                     spliti() (or any other regex function, for that\n *                     matter) is doing something weird, please read the\n *                     file regex.7, included in the regex/ subdirectory of\n *                     the PHP distribution. It's in manpage format, so\n *                     you'll want to do something along the lines of man\n *                     /usr/local/src/regex/regex.7 in order to read it.\n * @str        string  The input string.\n * @limit      int     If limit is set, the returned array will contain a\n *                     maximum of limit elements with the last element\n *                     containing the whole rest of string.\n *\n * @return     mixed   Returns an array of strings, each of which is a\n *                     substring of string formed by splitting it on\n *                     boundaries formed by the case insensitive regular\n *                     expression pattern.\n *\n *                     If there are n occurrences of pattern, the returned\n *                     array will contain n+1 items. For example, if there\n *                     is no occurrence of pattern, an array with only one\n *                     element will be returned. Of course, this is also\n *                     true if string is empty. If an error occurs,\n *                     spliti() returns FALSE.\n */",
"sql_regcase", T(String), S(0), "str", T(String), NULL, S(0), NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.sql-regcase.php )\n *\n * Creates a regular expression for a case insensitive match. WarningThis\n * function has been DEPRECATED as of PHP 5.3.0. Relying on this feature is\n * highly discouraged.\n *\n * @str        string  The input string.\n *\n * @return     string  Returns a valid regular expression which will match\n *                     string, ignoring case. This expression is string\n *                     with each alphabetic character converted to a\n *                     bracket expression; this bracket expression contains\n *                     that character's uppercase and lowercase form. Other\n *                     characters remain unchanged.\n */",

#elif EXT_TYPE == 1

#elif EXT_TYPE == 2

#endif
