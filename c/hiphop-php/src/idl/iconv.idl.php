<?php
/**
 * Automatically generated by running "php schema.php iconv".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "iconv_mime_encode",
    'desc'   => "Composes and returns a string that represents a valid MIME header field, which looks like the following: Subject: =?ISO-8859-1?Q?Pr=FCfung_f=FCr?= Entwerfen von einer MIME kopfzeile In the above example, \"Subject\" is the field name and the portion that begins with \"=?ISO-8859-1?...\" is the field value.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an encoded MIME field on success, or FALSE if an error occurs during the encoding.",
    ),
    'args'   => array(
      array(
        'name'   => "field_name",
        'type'   => String,
        'desc'   => "The field name.",
      ),
      array(
        'name'   => "field_value",
        'type'   => String,
        'desc'   => "The field value.",
      ),
      array(
        'name'   => "preferences",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "You can control the behaviour of iconv_mime_encode() by specifying an associative array that contains configuration items to the optional third parameter preferences. The items supported by iconv_mime_encode() are listed below. Note that item names are treated case-sensitive. Configuration items supported by iconv_mime_encode() Item Type Description Default value Example scheme string Specifies the method to encode a field value by. The value of this item may be either \"B\" or \"Q\", where \"B\" stands for base64 encoding scheme and \"Q\" stands for quoted-printable encoding scheme. B B input-charset string Specifies the character set in which the first parameter field_name and the second parameter field_value are presented. If not given, iconv_mime_encode() assumes those parameters are presented to it in the iconv.internal_encoding ini setting. iconv.internal_encoding ISO-8859-1 output-charset string Specifies the character set to use to compose the MIME header. If not given, the same value as input-charset will be used. iconv.internal_encoding UTF-8 line-length integer Specifies the maximum length of the header lines. The resulting header is \"folded\" to a set of multiple lines in case the resulting header field would be longer than the value of this parameter, according to » RFC2822 - Internet Message Format. If not given, the length will be limited to 76 characters. 76 996 line-break-chars string Specifies the sequence of characters to append to each line as an end-of-line sign when \"folding\" is performed on a long header field. If not given, this defaults to \"\\r\\n\" (CR LF). Note that this parameter is always treated as an ASCII string regardless of the value of input-charset. \\r\\n \\n",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_MUTATED",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "iconv_mime_decode",
    'desc'   => "Decodes a MIME header field.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a decoded MIME field on success, or FALSE if an error occurs during the decoding.",
    ),
    'args'   => array(
      array(
        'name'   => "encoded_string",
        'type'   => String,
        'desc'   => "The encoded header, as a string.",
      ),
      array(
        'name'   => "mode",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "mode determines the behaviour in the event iconv_mime_decode() encounters a malformed MIME header field. You can specify any combination of the following bitmasks. Bitmasks acceptable to iconv_mime_decode() Value Constant Description 1 ICONV_MIME_DECODE_STRICT If set, the given header is decoded in full conformance with the standards defined in » RFC2047. This option is disabled by default because there are a lot of broken mail user agents that don't follow the specification and don't produce correct MIME headers. 2 ICONV_MIME_DECODE_CONTINUE_ON_ERROR If set, iconv_mime_decode_headers() attempts to ignore any grammatical errors and continue to process a given header.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The optional charset parameter specifies the character set to represent the result by. If omitted, iconv.internal_encoding will be used.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_MUTATED",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "iconv_mime_decode_headers",
    'desc'   => "Decodes multiple MIME header fields at once.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an associative array that holds a whole set of MIME header fields specified by encoded_headers on success, or FALSE if an error occurs during the decoding.\n\nEach key of the return value represents an individual field name and the corresponding element represents a field value. If more than one field of the same name are present, iconv_mime_decode_headers() automatically incorporates them into a numerically indexed array in the order of occurrence.",
    ),
    'args'   => array(
      array(
        'name'   => "encoded_headers",
        'type'   => String,
        'desc'   => "The encoded headers, as a string.",
      ),
      array(
        'name'   => "mode",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "mode determines the behaviour in the event iconv_mime_decode_headers() encounters a malformed MIME header field. You can specify any combination of the following bitmasks. Bitmasks acceptable to iconv_mime_decode_headers() Value Constant Description 1 ICONV_MIME_DECODE_STRICT If set, the given header is decoded in full conformance with the standards defined in » RFC2047. This option is disabled by default because there are a lot of broken mail user agents that don't follow the specification and don't produce correct MIME headers. 2 ICONV_MIME_DECODE_CONTINUE_ON_ERROR If set, iconv_mime_decode_headers() attempts to ignore any grammatical errors and continue to process a given header.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The optional charset parameter specifies the character set to represent the result by. If omitted, iconv.internal_encoding will be used.",
      ),
    ),
    // NB: TaintObserver declared in f_iconv_mime_decode_headers
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv_get_encoding",
    'desc'   => "Retrieve internal configuration variables of iconv extension.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the current value of the internal configuration variable if successful or FALSE on failure.\n\nIf type is omitted or set to \"all\", iconv_get_encoding() returns an array that stores all these variables.",
    ),
    'args'   => array(
      array(
        'name'   => "type",
        'type'   => String,
        'value'  => "\"all\"",
        'desc'   => "The value of the optional type can be: all input_encoding output_encoding internal_encoding",
      ),
    ),
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv_set_encoding",
    'desc'   => "Changes the value of the internal configuration variable specified by type to charset.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "type",
        'type'   => String,
        'desc'   => "The value of type can be any one of those: input_encoding output_encoding internal_encoding",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'desc'   => "The character set.",
      ),
    ),
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv",
    'desc'   => "Performs a character set conversion on the string str from in_charset to out_charset.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the converted string or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "in_charset",
        'type'   => String,
        'desc'   => "The input charset.",
      ),
      array(
        'name'   => "out_charset",
        'type'   => String,
        'desc'   => "The output charset.\n\nIf you append the string //TRANSLIT to out_charset transliteration is activated. This means that when a character can't be represented in the target charset, it can be approximated through one or several similarly looking characters. If you append the string //IGNORE, characters that cannot be represented in the target charset are silently discarded. Otherwise, str is cut from the first illegal character and an E_NOTICE is generated.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string to be converted.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_MUTATED",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "iconv_strlen",
    'desc'   => "In contrast to strlen(), iconv_strlen() counts the occurrences of characters in the given byte sequence str on the basis of the specified character set, the result of which is not necessarily identical to the length of the string in byte.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the character count of str, as an integer.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If charset parameter is omitted, str is assumed to be encoded in iconv.internal_encoding.",
      ),
    ),
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv_strpos",
    'desc'   => "Finds position of first occurrence of a needle within a haystack.\n\nIn contrast to strpos(), the return value of iconv_strpos() is the number of characters that appear before the needle, rather than the offset in bytes to the position where the needle has been found. The characters are counted on the basis of the specified character set charset.\nIf haystack or needle is not a string, it is converted to a string and applied as the ordinal value of a character.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the numeric position of the first occurrence of needle in haystack.\n\nIf needle is not found, iconv_strpos() will return FALSE. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The entire string.",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The searched substring.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The optional offset parameter specifies the position from which the search should be performed.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If charset parameter is omitted, string are assumed to be encoded in iconv.internal_encoding.",
      ),
    ),
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv_strrpos",
    'desc'   => "In contrast to strpos(), the return value of iconv_strrpos() is the number of characters that appear before the needle, rather than the offset in bytes to the position where the needle has been found.\nIf haystack or needle is not a string, it is converted to a string and applied as the ordinal value of a character.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the numeric position of the last occurrence of needle in haystack. The characters are counted on the basis of the specified character set charset.\n\nIf needle is not found, iconv_strrpos() will return FALSE. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The entire string.",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The searched substring.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If charset parameter is omitted, string are assumed to be encoded in iconv.internal_encoding.",
      ),
    ),
    'taint_observer' => false,
  ));

DefineFunction(
  array(
    'name'   => "iconv_substr",
    'desc'   => "Cuts a portion of str specified by the offset and length parameters.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the portion of str specified by the offset and length parameters.\n\nIf str is shorter than offset characters long, FALSE will be returned.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The original string.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'desc'   => "If offset is non-negative, iconv_substr() cuts the portion out of str beginning at offset'th character, counting from zero.\n\nIf offset is negative, iconv_substr() cuts out the portion beginning at the position, offset characters away from the end of str.",
      ),
      array(
        'name'   => "length",
        'type'   => Int32,
        'value'  => "INT_MAX",
        'desc'   => "If length is given and is positive, the return value will contain at most length characters of the portion that begins at offset (depending on the length of string).\n\nIf negative length is passed, iconv_substr() cuts the portion out of str from the offset'th character up to the character that is length characters away from the end of the string. In case offset is also negative, the start position is calculated beforehand according to the rule explained above.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If charset parameter is omitted, string are assumed to be encoded in iconv.internal_encoding.\n\nNote that offset and length parameters are always deemed to represent offsets that are calculated on the basis of the character set determined by charset, whilst the counterpart substr() always takes these for byte offsets.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_MUTATED",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "ob_iconv_handler",
    'desc'   => "Converts the string encoded in internal_encoding to output_encoding.\n\ninternal_encoding and output_encoding should be defined in the php.ini file or in iconv_set_encoding().\nSee ob_start() for information about this handler parameters.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "See ob_start() for information about this handler return values.",
    ),
    'args'   => array(
      array(
        'name'   => "contents",
        'type'   => String,
      ),
      array(
        'name'   => "status",
        'type'   => Int32,
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_MUTATED",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

